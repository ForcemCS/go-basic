### 1. 常规 HTTP 响应（带 `Content-Length`）

这是最常见的 Web 响应方式。

1. **服务器处理：** 服务器接收到请求后，执行所有逻辑，将要返回的**全部内容**（比如整个 HTML 页面）在内存中准备好。
2. **计算大小：** 服务器计算出这个完整内容的总大小（例如，10240 字节）。
3. **设置响应头：** 服务器在 HTTP 响应头中设置 `Content-Length: 10240`。
4. **发送数据：** 服务器将响应头和**全部内容一次性**发送给浏览器。
5. **浏览器渲染：** 浏览器接收数据，直到收满 `Content-Length` 指定的 10240 字节后，才开始解析和渲染整个页面。

**缺点：** 如果服务器生成响应内容需要很长时间（比如一个复杂的数据库查询或 AI 生成内容），那么浏览器必须一直等待，直到服务器准备好所有内容。这会导致用户看到很长时间的白屏，体验不佳。

### 2. 流式 HTTP 响应（`Transfer-Encoding: chunked`）

1. **服务器处理：** 服务器接收到请求后，**不等待**所有内容都生成完毕。
2. **设置响应头：** 服务器立即发送一个响应头，其中包含 `Transfer-Encoding: chunked`。这个头告诉浏览器：“我不知道总内容有多大，我会一块一块地发给你，你收到一块就处理一块。” **注意：此时不能设置 `Content-Length`。**
3. **发送数据块：** 服务器每准备好一小部分数据（一个 "chunk"），就立即把它发送给浏览器。
4. **浏览器渲染：** 浏览器每接收到一个数据块，就立即对这部分内容进行解析和渲染。用户可以先看到页面的部分内容，然后看着新内容被逐渐“流”进来。
5. **结束传输：** 当所有数据块都发送完毕后，服务器会发送一个特殊的“零长度块”作为结束标志，告诉浏览器数据传输完成了。

**优点：** 极大地提升了首屏加载速度和用户体验，特别适合那些需要动态生成、内容巨大或耗时较长的响应。

```
// 标准的 Go HTTP Handler，w 用于写入响应，r 包含了请求信息
func ChunkedTransfer(w http.ResponseWriter, r *http.Request) {
    // 1. 设置响应状态码为 200 OK
    w.WriteHeader(http.StatusOK)

    // 2. 设置内容类型，告诉浏览器这是一个 HTML 文档
    w.Header().Add("Content-Type", "text/html")

    // 3. 【核心】设置分块传输编码
    // 这行代码是启用流式响应的关键。它告诉客户端，服务器将以分块的方式发送数据。
    w.Header().Add("Transfer-Encoding", "chunked")

    // 4. 【核心】获取 http.Flusher 接口
    // http.ResponseWriter 是一个接口。Go 的 http 服务器在底层实现它时，通常会额外实现 http.Flusher 接口。
    // 这个类型断言 `w.(http.Flusher)` 就是检查当前的 ResponseWriter 是否支持 Flush() 操作。
    // Flush() 的作用是强制将服务器内部缓冲区的数据立刻发送到客户端。
    flusher, ok := w.(http.Flusher)
    if !ok {
        // 如果不支持，就无法实现流式刷新，程序直接报错返回。
        http.Error(w, "Streaming unsupported!", http.StatusInternalServerError)
        return
    }

    // 5. 发送 HTML 的起始部分
    // 这部分内容会先被写入到服务器的响应缓冲区中。
    fmt.Fprintf(w, "<html><body><ol>")

    // 假设 contents 是一个包含多段文本的切片
    // var contents = []string{"第一部分数据", "第二部分数据", "第三部分数据", "..."}
    for _, chunk := range contents {
        // 6. 循环发送数据块
        // 将列表中的一项写入缓冲区
        fmt.Fprintf(w, "<li>%s</li>", chunk)

        // 7. 【核心】刷新缓冲区
        // 这是让“流式”生效的魔法！调用 flusher.Flush() 会强制将缓冲区里
        // 刚刚写入的 "<li>...</li>" 立刻通过网络发送给浏览器。
        // 如果没有这行代码，数据会一直暂存在缓冲区，直到函数结束才一次性发送。
        flusher.Flush()

        // 8. 人为延迟，以便观察效果
        // 这行代码在生产环境中通常是不需要的。
        // 在这里它的作用是模拟一个耗时的操作（比如查询数据库），
        // 让你可以在浏览器中清晰地看到列表项是一秒钟出现一个，而不是瞬间全部加载。
        time.Sleep(time.Second)
    }

    // 9. 发送 HTML 的结尾部分
    // 循环结束后，发送 HTML 的闭合标签。
    fmt.Fprintf(w, "</ol></body></html>")
    // 在函数结束时，Go 的 http 服务器会自动处理最后的刷新和关闭连接，
    // 确保最后这部分内容也被发送出去，并告知浏览器响应结束。
}
```

### 3. Server-Sent Events (SSE)

这是一种基于 HTTP 协议的**单向**通信技术，允许服务器主动向浏览器（客户端）推送数据，而不需要客户端反复轮询。

你可以把它理解为 **“收音机广播”** 模式：

- **客户端（浏览器）** 拨通了一个频道（发起 HTTP 请求）。
- **服务器** 保持这个频道畅通，不挂断电话。
- **服务器** 随时可以通过这个频道念一段新闻（推送数据）。
- **客户端** 听到一段就处理一段。

它和上一个例子（Chunked Transfer）的底层机制是一样的（都用了分块传输），但 SSE 定义了一套 **严格的文本格式标准**，浏览器有专门的 API (`EventSource`) 来解析它。

### 4. cookie

#### 1. 核心问题：HTTP 是“健忘”的（无状态）

**问题场景：**
HTTP 协议设计之初是用来浏览静态文档的。服务器处理完你的请求（比如“给我看首页”），发回网页后，就立刻断开连接，并且**把你忘得一干二净**。

如果你登录了网站，输入了账号密码。

1. **请求 1：** “我是小明，这是我的密码，我要登录。” -> **服务器：** “通过，欢迎小明。”
2. **请求 2：** “我要看我的购物车。” -> **服务器：** “你是谁？我不认识你。请先登录。”

**如果没有 Cookie：** 你每点一个链接，每刷新一次页面，都得重新输入一次账号密码。这对现代交互式网页（网银、淘宝、邮箱）来说是灾难。

#### 2. 解决方案：Cookie 机制

为了让服务器“记性好”一点，网景公司（Netscape）发明了 Cookie。

**工作流程：**

1. **发票（Set-Cookie）：**
   当你登录成功后，服务器在 HTTP 响应头里加一行：
   `Set-Cookie: session_id=xyz123; Expires=Wed, 21 Oct 2026...`
   这就好比服务器给你发了一张会员卡，卡号是 `xyz123`。
2. **存票（Storage）：**
   浏览器收到响应后，发现有 `Set-Cookie`，就会把这个键值对（Key-Value）保存在浏览器的本地文件或内存里。
3. **亮票（Cookie Header）：**
   当你再访问该网站的任何页面（如“购物车”）时，**浏览器会自动**检查有没有属于这个域名的 Cookie。如果有，它会在 HTTP 请求头里自动带上：
   `Cookie: session_id=xyz123`
4. **识别：**
   服务器收到请求，从头里读出 `session_id=xyz123`，去数据库一查：“哦，xyz123 对应的是小明，已经登录过了。准许通过！”

------

#### 3. Cookie 主要解决的三大问题

1. **会话管理（Session Management）：最主要的功能**
   - 用户登录状态（记住你已经登录了）。
   - 购物车（你往车里放了什么商品）。
   - 游戏分数。
2. **个性化设置（Personalization）：**
   - 你选择了“暗黑模式”。
   - 你选择了“中文”语言。
   - 下次来直接展示你喜欢的设置。
3. **追踪分析（Tracking）：**
   - 广告商通过 Cookie 记录你访问过什么网站，看了什么商品，然后在别的网站给你推同类广告（这通常被称为“第三方 Cookie”）。

------

#### 4. Cookie 的关键属性（安全与控制）

在 HTTP 编程中，设置 Cookie 不仅仅是给个 Value，还需要设置各种属性来保证安全：

- **Name/Value**：数据本身（如 `token=abc`）。
- **Domain/Path**：**作用域**。规定这张票在哪些页面有效。例如，设置在 `google.com` 的 Cookie 不会发给 `baidu.com`。
- Expires/Max-Age：有效期。
  - 如果不设置，就是**会话 Cookie**，浏览器一关就丢了。
  - 如果设置了时间，就是**持久 Cookie**，存在硬盘里，重启电脑还在。
- **Secure**：**仅 HTTPS**。告诉浏览器，只有在加密连接时才能发送这个 Cookie，防止被窃听。
- **HttpOnly**：**防 XSS 攻击**。**非常重要！** 设置了这个属性后，JavaScript 代码（`document.cookie`）就读不到这个 Cookie 了。这样即使黑客在页面注入了恶意脚本，也偷不走你的登录凭证。
- **SameSite**：**防 CSRF 攻击**。限制跨站发送 Cookie。
