## 什么是array

Go 语言中的数组与其他编程语言中的数组非常相似。它们具有固定的大小，并将相同类型的元素存储在连续的内存位置中

这意味着 Go 可以快速访问每个元素，因为它们的地址是根据数组的起始地址和元素的索引计算出来的。

```go
func main() {
	arr := [5]byte{0, 1, 2, 3, 4}
	println("arr", &arr)

	for i := range arr {
		println(i, &arr[i])
	}
}

// arr 0x1400005072b
// 0 0x1400005072b
// 1 0x1400005072c
// 2 0x1400005072d
// 3 0x1400005072e
// 4 0x1400005072f
```

这里有两点需要注意：

+ 数组 `arr` 的地址与第一个元素的地址相同。
+ 由于我们的元素类型是 `byte` ，因此每个元素的地址彼此相差 1 个字节。

<img src="./img/1.png" alt="1" style="zoom:50%;" />

我们的堆栈是从较高的地址向下增长到较低的地址，对吧？这张图准确地显示了堆栈中数组的样子，从 `arr[4]` 到 `arr[0]` 。

那么，这是否意味着我们可以通过知道数组首元素（或数组本身）的地址和元素的大小来访问数组中的任何元素呢？我们可以通过指针来访问元素（unsafe.**Pointer**），**切勿在生产环境中使用这种方法。！**

请看下边的一段代码

```go
func main() {
    a := [5]byte{}
    b := [4]byte{}

    fmt.Printf("%T\n", a) // [5]uint8
    fmt.Printf("%T\n", b) // [4]uint8


    a = b 
}
```

虽然它们的**元素类型**都是 `byte`（也就是 `uint8`）， 但**长度不同 → 类型不同**，所以数组偏底层、偏内存布局、偏系统编程

## 数组字面量

`a := [3]int{1, 2, 3}`

实际上同时做了 **三件事**：1.**定义一个类型**：`[3]int` 2.  **分配一块固定大小内存 **3. **把初始值按顺序写进去**

```go
var m map[[2]int]string

m[[2]int{1, 2}] = "point"

```

上边的代码可以作为map的key 

### 常见字面量写法

+ `a := [3]int{1, 2, 3}`

+ `a := [...]int{1, 2, 3, 4}`自动推导长度，不是“不定长”，而是“让编译器数一数”

+ 指定下标

  ```
  a := [5]int{
      0: 100,
      3: 200,
  }
  //[100, 0, 0, 200, 0]
  ```

+ 部分初始化

  ```
  a := [4]string{"a", "b"}
  //["a", "b", "", ""]
  ```

### 数组包含原始值

Go 将数组视为值类型。这意味着 Go 中的数组变量代表整个数组，而不仅仅是对其第一个元素的引用，即使打印 `&a` 打印 `&a[0]` 得到的地址相同。

```go
package main

import "fmt"

func doSomething(a [5]byte) {
	a[0] = 1
	fmt.Println(a)   // [0 0 0 0 0]
}

func main() {
	a := [5]byte{}
	doSomething(a)
	fmt.Println(a)  // [0 0 0 0 0] 
}

//这是预期的输出结果，因为我们修改的是复制的数组，而不是原始数组。
```

### 遍历数组

```go
func main() {
	a := [3]int{1, 2, 3}
	b := [3]int{4, 5, 6}

	for i, v := range a {
		if i == 1 {
			a = b
		}
		fmt.Println(v)
	}
}
```

上边的代码有一个陷阱，go实际看到的代码如下

```go
func main() {
	a := [3]int{1, 2, 3}
	b := [3]int{4, 5, 6}

    a1 := a
	for i, v := range a1 {
		if i == 1 {
			a = b
		}
		fmt.Println(v)
	}
}
```

这意味着它的工作方式类似于按值传递。如果我们的数组远大于几个元素，像这样进行复制效率会很低，Go 团队已经通过允许使用指向数组的指针进行 for-range 循环来优化了这一点。

```
func main() {
	a := [3]int{1, 2, 3}
	b := [3]int{4, 5, 6}

	for i, v := range &a {
		if i == 1 {
			a = b
		}
		fmt.Println(v)
	}
}
```

现在的输出结果是 1 2 6，正如我们最初预期的那样。但这里的关键并非鼓励在循环内修改数组，不建议这样做。而是要说明 Go 支持使用指向数组的指针进行 for-range 循环
