## 前言

我们把 **Protobuf** 想象成一套**“通用家具设计标准”**。

目标是：设计了一款柜子，你想让全世界的木工（Go语言、Java语言、Python语言）都能把这个柜子造出来，并且能把东西（数据）装进去打包运走。

### 1. `.proto` 文件 —— “宜家图纸”

当你打开一个 `.proto` 文件写代码时，你其实是在**画图纸**。

- 你不需要告诉木工“先锯木头、再刷漆”（那是具体的编程逻辑）。
- 你只需要画出：这个柜子有几个抽屉？抽屉叫什么名字？尺寸是多少？
- **关键点：** 这张图纸是**通用**的。不管你是美国木工还是中国木工，看图纸都知道这是个柜子。

### 2. `protoc` —— “工厂总监”

`protoc` 是 Google 派来的**总监**。他手里拿着你的图纸。

- 但他不干脏活累活，他也不会亲自造柜子。
- 他的作用只有一个：**分发任务**。
- 他看着图纸问你：“老板，你今天要造给谁用的柜子？是给讲 Go 语言的人用，还是给讲 Python 的人用？”

### 3. `protoc-gen-go` —— “Go 语言模具 / 专门的流水线”

这就是具体的**干活的机器**（插件）。

- 当总监 (`protoc`) 知道你要生成 Go 代码时，他就会按下按钮，启动这条叫做 `protoc-gen-go` 的流水线。
- 这条流水线懂得 Go 语言的规则。它接过图纸，哐哧哐哧一顿操作，生产出了一个**半成品组件**（这就是 `*.pb.go` 文件）。
- **为什么需要它？** 因为总监不懂 Go 语言的语法（比如结构体怎么写），只有这个插件懂。

### 4. `*.pb.go` —— “定制好的板材包”

这是插件吐出来的**结果**。它就像是你买回家的宜家**平板包装箱**。

- 打开这个文件（或者箱子），里面整整齐齐放好了 Go 语言能用的 Struct（结构体）。
- 以前你自己写代码可能要手写 `type User struct {...}`，现在不用了，这个文件里全给你自动写好了。

### 5. Runtime Library (google.golang.org/protobuf) —— “万能螺丝刀和五金件”

这是最容易晕的地方。请注意听：

虽然你有板材（`*.pb.go`），但你**没法把柜子拼起来**，也没法把柜子拆开。为什么？因为你**缺工具**。

- **Runtime Library 就是那把“万能螺丝刀”和配套的“螺丝钉”。**
- 生成的 `*.pb.go` 代码里，其实只定义了板材的形状。但是，当你想要把一个内存里的对象**压缩**成二进制（打包），或者把二进制**解压**成对象（拆包）时，需要复杂的算法。
- 这些复杂的算法逻辑，都在 Runtime Library 里。
- 所以，你的代码（`.pb.go`）必须引用（Import）这个库，才能真正干活。

### 重新梳理一遍流程（场景版）

1. **你（设计师）**：写了一个 `user.proto`（画好了图纸，说我要一个 User 柜子，存名字和ID）。

2. **你喊了一声**：`protoc --go_out=. user.proto`（嘿，总监！把这图纸拿去，给我造一套 Go 语言用的板材！）。

3. **总监 (`protoc`)**：收到！呼叫 `protoc-gen-go` 插件（模具），开始加工！

4. **结果**：生成了 `user.pb.go` 文件（板材包）。你把它放进你的 Go 项目里。

5. 实际使用

   ：

   - 你想把一个 User 数据存进硬盘。
   - 你的代码调用 `user.pb.go` 里的方法。
   - `user.pb.go` 实际上是借用了 **Runtime Library（螺丝刀）** 的能力，咔咔几下，把数据拧紧，变成了一串极小的二进制数据。

### 为什么这么麻烦？

你可能会问：“为什么要分总监、插件、库这么多东西？”

这是为了**解耦（各司其职）**：

- **Google (Protoc)** 只需要维护通用的逻辑。
- **Go 社区** 只需要维护 `protoc-gen-go` 插件和 Go 的 Runtime。
- **Python 社区** 只需要维护 Python 的插件和 Runtime。

这样，如果明天出了一门新语言（比如 Rust），Google 不用改 `protoc`，只需要 Rust 社区写一个新的插件和 Runtime，大家就能用 Protobuf 了。

## Message & Tag

### 1. 什么是 Message 和 Tag？

```protobuf
message Person {
 string name = 1;
 int32 id = 2;
 string email = 3;
}
```

想象你在超市，有一排**储物柜**。

- `message Person` 就是这排柜子的整体。
- `name`、`id`、`email` 是你贴在柜子门上的**贴纸**（给人看的）。
- **`= 1`、`= 2`、`= 3` 才是刻在柜子金属门上的编号（给机器看的）。**

**重点来了：**
Protobuf 这个“快递员”在传输数据时，**完全不看贴纸（字段名），只认柜子号（Tag Number）**。

- 当 Protobuf 把数据打包成二进制时，它不会把 "name" 这个单词写进去，它只会写：**“1号柜子里放的是 Alice”**。
- 接收方收到数据后，一看是“1号柜”，就去查自己的定义：“哦，1号柜是名字”，于是把它取出来。

------

### 2. 为什么改名没事？（Renaming）

文中提到：你可以把 `string name = 1;` 改成 `string full_name = 1;`，两边的系统依然能完美通信。

**为什么？**
还是那个储物柜的例子：

- **发送方（Service A）**：在 1 号柜门上贴了“Name”。它把 "Alice" 放进了 1 号柜。
- **接收方（Service B）**：觉得“Name”这词不好听，把 1 号柜门上的贴纸撕了，换成了“FullName”。
- **通信过程**：发送方告诉快递员：“把 1 号柜的东西送过去”。快递员送到接收方那里，把东西塞进 1 号柜。

**结果**：完全不影响！因为快递员（Protobuf）根本不识字，他只认**数字 1**。只要**编号**和**数据类型**（string）对得上，名字随便你怎么改。

------

### 3. 删除字段时的隐患（Reserved）

这是新手最容易引发**重大事故**的地方。

假设你的产品升级了，不需要 `email` 字段了。
你把 `.proto` 文件里的 `string email = 3;` 删掉了。

**危险场景：**
一个月后，来了一个新同事。他想加一个“家庭住址”字段。
他一看：*“咦，3号没人用嘛，那我就用吧！”*
于是他写了：`string address = 3;`

**灾难发生了：**

1. **老版本的 App（还在用户手机里）**：依然往 3 号柜里塞“Email”。
2. **新版本的服务器**：以为 3 号柜里装的是“Address”。
3. **结果**：服务器试图把“xxx@gmail.com”当作地址处理，程序可能直接崩溃，或者数据错乱。

**解决办法：Reserved（封条）**
为了防止这种“新房客住进凶宅”的情况，当你删除一个字段时，必须给这个编号贴上封条：

```protobuf
message Person {
  // 兄弟们，2号和3号柜子以前用过，不管现在空没空，以后谁都不许再占用！
  reserved 2, 3; 
  reserved "email"; // 名字也最好封存一下
}
```

这样，如果新同事试图写 `string address = 3;`，编译器（`protoc`）会直接报错，阻止他犯错。

------

### 4. 为什么要保留名字？（JSON 兼容）

你可能会问：*“你刚才不是说 Protobuf 只认数字，不认名字吗？那为什么还要 `reserved "email"`？”*

**原因：**
虽然 Protobuf 传输只看数字，但有时候我们需要把 Protobuf 转成 **JSON**（比如给前端网页用）。
JSON 是看名字的（`{ "email": "..." }`）。如果你复用了 `email` 这个名字但含义变了，前端解析 JSON 时就会懵圈。所以为了安全起见，名字也最好占坑。

------

### 5. 性能小贴士（1 到 15）

文中最后提到：*Keep them between 1 and 15.*

这是为了**省流量**。
在二进制编码中：

- **编号 1 到 15**：只需要 **1 个字节（Byte）** 就能记录下“这是几号柜”以及“里面是什么类型”。
- **编号 16 到 2047**：需要 **2 个字节**。

**类比：**
这就像手机里的**“单键快速拨号”**。你只有 15 个快速拨号键。
你应该把你**最常用**的字段（比如 ID、Name、Type）放在 1-15 号。
把那些不常用的、生僻的字段放在 16 号以后。