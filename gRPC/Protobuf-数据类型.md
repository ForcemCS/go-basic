# 数据类型

## Scalar Types 标量类型

Protobuf 支持多种标量类型。它们看起来可能很相似，尤其是在它们能承受的数值范围上。但真正的区别在于它们的连载方式。

1. **绝大多数情况（正数、ID、计数）**：
   - 用 **`int32` / `int64`**。这是默认选择，大部分时候数字都不大，能省很多空间。
2. **全是很大的数（比如时间戳、哈希值、大文件长度）**：
   - 用 **`fixed32` / `fixed64`**。如果不确定，只要数字经常超过 2.6 亿 ($2^{28}$)，就选它。
3. **可能会有负数（比如温度、经纬度增量、盈亏额）**：
   - **千万别用 `int32`！** 一定要用 **`sint32` / `sint64`**。
   - *如果你不确定有没有负数，为了安全起见，选 `sint` 系列总没错。*

## Enum枚举

### 1. 什么是 Enum？（菜单与编号）

```protobuf
enum Version {
 VERSION_UNSPECIFIED = 0;
 VERSION_PROTO1 = 1;
 ...
}
```

计算机喜欢处理数字（0, 1, 2），但程序员喜欢看单词（Unspecified, Proto1）。Enum 就是这两者之间的**翻译官**。

- 你写代码时用 `VERSION_PROTO1`。
- Protobuf 传输数据时，实际上传输的是数字 `1`。

### 2. 为什么 0 号一定要留空？（安全网原则）

文档强烈建议：**把 0 号留给 `UNSPECIFIED`（未指定/未知）。**

**原因：**
在 Protobuf 3 中，如果你创建一个对象但忘了给 Enum 字段赋值，它的默认值就是 **0**。

- **错误示范：** 假设你定义 `0 = ONLINE`（在线），`1 = OFFLINE`（离线）。如果你忘了设置状态，系统会默认为“在线”。这可能导致严重的逻辑错误。
- **正确做法：** 定义 `0 = UNSPECIFIED`，`1 = ONLINE`。如果你忘了设置，系统会显示“未指定”，这样你很容易发现数据有问题。

### 3. Alias（别名）：同一个菜的两个名字

```protobuf
enum Version {
 option allow_alias = true; // 开启别名功能
 ...
 VERSION_EDITION2023 = 4;
 VERSION_LATEST = 4;        // LATEST 也是 4
}
```

有时候，你想给同一个数字起两个名字。

- **场景：** 菜单上的“4号菜”是“红烧肉”。你想加一个名字叫“招牌菜”，也指向“4号”。
- **配置：** 默认情况下，Protobuf 禁止两个名字共用一个数字（怕你写错了）。如果你非要这么做，必须显式加上 `option allow_alias = true;`。

### 4. 反序列化的“失忆”现象（重点难点）

文中提到的 Question 很有意思：

> *"How does the compiler know which alias to use when deserializing?"*
> （反序列化时，编译器怎么知道该用哪个名字？）

**答案是：它不知道，它也不在乎。**

继续用菜单的例子：

1. **发送方**：我要点一份 `VERSION_LATEST`（招牌菜）。
2. **传输中**：Protobuf 把这单子记为 **“4号”** 发出去了。
3. **接收方**：收到了 **“4号”**。它拿起菜单一看，发现 `VERSION_EDITION2023` 是 4号，`VERSION_LATEST` 也是 4号。
4. **结果**：Protobuf 比较“懒”，它通常会直接匹配它找到的**第一个**名字（也就是 `VERSION_EDITION2023`）。

**这意味着什么？**
虽然你发出去的是“LATEST”，但对方收到的代码对象里，打印出来的名字可能是“EDITION2023”。这在逻辑上没问题（因为值都是4），但如果你代码里依赖具体的“字符串名字”做判断，可能会出 bug。

### 5. 性能陷阱：别用负数

**切记：Enum 在底层处理时，和 `int32` 是一样的。**

回顾上一节课的内容：`int32` 处理负数非常低效（需要 10 个字节）。
所以，**绝对不要给 Enum 定义负数值**（比如 `ERROR = -1`）。这会浪费大量的传输流量。

### 6. Reserved（封条）：防止“上错菜”

和 Message 一样，如果你删除了某个枚举值（比如删除了 `VERSION_PROTO1 = 1`），一定要把 **1** 这个数字和名字都 `reserved`（保留/封存）。

```protobuf
enum Version {
  reserved 1; 
  reserved "VERSION_PROTO1"; // 名字也封存
}
```

**原因：** 防止以后新来的同事把“1号”重新定义成了别的含义，导致老版本的系统解析错误。

### 7. 语法小坑（Proto3 vs Edition 2023）

文末提到了一个小细节，是关于写法的：

- Proto3（目前最常用的版本）：

   保留名字时要加引号。

  - `reserved "VERSION_PROTO1";`

- Edition 2023（Google 推出的最新一代语法）：

   保留名字时不加引号。

  - `reserved VERSION_PROTO1;`

这只是写法上的区别，不用太纠结，根据你使用的编译器版本来写就行。

## Repeated

**问题核心：**
当一个数字（比如 `4`）被赋予了两个名字（`VERSION_EDITION2023` 和 `VERSION_LATEST`）时，Protobuf 在把二进制数据变回代码对象时，到底会选择哪个名字？

**直接答案：它会选择在 `.proto` 文件中定义在前面的那个名字。**

### 场景设定

**发送方 (Service A)** 的 `.proto` 文件定义如下：

```protobuf
enum Version {
  option allow_alias = true; // 允许别名
  VERSION_UNSPECIFIED = 0;
  // ... 其他定义 ...
  VERSION_EDITION2023 = 4;   // 名字1
  VERSION_LATEST = 4;        // 名字2 (别名)
}
```

**接收方 (Service B)** 使用完全相同的 `.proto` 文件。

### 旅程开始：序列化（打包数据）

1. **在发送方的代码中**：
   你创建了一个消息对象，并把版本字段设置为了 `VERSION_LATEST`。
   `myMessage.setVersion(Version.VERSION_LATEST);`
2. **Protobuf 开始打包**：
   Protobuf 拿到了你设置的 `VERSION_LATEST`。它做的第一件事就是去查 `.proto` 的定义：“`VERSION_LATEST` 对应的数字是多少？”
   答案是 **`4`**。
3. **生成二进制数据**：
   Protobuf 会将数字 **`4`** 编码成二进制格式。在这个过程中，**"VERSION_LATEST" 这个字符串名字被彻底丢弃了**。它根本不会出现在最终的二进制数据里。网络上传输的，只有一个代表 `4` 的二进制值。
   - **关键点**：数据在传输时已经“失忆”了，它只记得自己是 `4`，不记得自己曾经叫 `VERSION_LATEST`。

### 旅程中点：网络传输

一串包含数字 `4` 的二进制数据在网络中飞驰，从 Service A 到达 Service B。

### 旅程终点：反序列化（解开包裹）

1. **接收方收到数据**：
   Service B 的 Protobuf 库开始解析这串二进制数据。当它读到版本字段时，它读出了一个数字：**`4`**。
2. **寻找匹配的名字（决定性的时刻！）**：
   现在，Protobuf 需要把这个光秃秃的数字 `4` 翻译回程序员能看懂的 `Version` 枚举类型。它会打开 `.proto` 文件，像一个“按顺序查字典”的机器人一样：
   - 它从上到下扫描 `enum Version` 的定义。
   - `VERSION_UNSPECIFIED = 0;` ... 不匹配。
   - ...
   - `VERSION_EDITION2023 = 4;` -> **匹配成功！**
3. **停止查找并赋值**：
   一旦找到了第一个匹配项 (`VERSION_EDITION2023`)，**它的任务就完成了**。它会立即停止继续向下查找，直接将接收到的对象中的版本字段设置为 `VERSION_EDITION2023`。它永远不会看到后面还有一个 `VERSION_LATEST` 也等于 `4`。

### 最终结果

- 你发送时用的是 `VERSION_LATEST`。
- 对方接收后，如果打印这个字段，显示的名字会是 `VERSION_EDITION2023`。

### 这会造成问题吗？

- **99% 的情况不会**：因为在程序逻辑判断中，`VERSION_LATEST` 和 `VERSION_EDITION2023` 的值都是 `4`。

  - `if (receivedVersion == Version.LATEST)` 这个判断依然是 `true`，因为实际上是在比较 `if (4 == 4)`。

- **1% 的情况可能会（坏代码的例子）**：如果你的代码依赖枚举的**字符串名字**进行判断，就会出问题。

  ```java
  // 这是一个非常糟糕的编程习惯！
  if (receivedVersion.toString().equals("VERSION_LATEST")) {
      // 这段代码永远不会被执行！
      // 因为 receivedVersion.toString() 的结果会是 "VERSION_EDITION2023"
      log("这是一个最新的客户端！");
  }
  ```

## Map

### 1. 你眼中的 `map`：一本通讯录

当你定义这个字段时：

```protobuf
map<string, string> emails = 2;
```

你想要的是一个像 Python 字典或 Java HashMap 一样的东西。在你的代码里，你可以很自然地这样用：

- `emails["work"] = "ceo@google.com";`
- `emails["home"] = "user@gmail.com";`

这就像一本**通讯录**，你可以通过“工作”、“家庭”这些**标签（Key）**，快速找到对应的**联系方式（Value）**。用起来非常方便、直观。

------

### 2. Protobuf 眼中的 `map`：一堆名片

**这是这段内容的核心。**

Protobuf 的底层设计里，其实**没有“通讯录”这个概念**。它只有一些基础零件，比如 `message`（消息）和 `repeated`（列表/数组）。

所以，为了实现“通讯录”的功能，Protobuf 耍了个花招。它在背后偷偷地把你的 `map` 定义转换成了两样东西：

**第一步：定义一张“名片”的模板**
它先在内部创建了一个你看不到的 `message`，我们叫它 `EmailsEntry`（邮件条目）：

```protobuf
message EmailsEntry {
  string key = 1;   // 用来写标签，比如 "work"
  string value = 2; // 用来写联系方式，比如 "ceo@google.com"
}
```

这就像设计了一张标准的**名片模板**，上面有两个空栏：一个是“分类”，一个是“邮箱”。

**第二步：准备一个“名片夹”**
然后，它把你原来的 `emails` 字段改成了这样：

```protobuf
repeated EmailsEntry emails = 2;
```

`repeated` 关键字的意思是“一个列表”或“一个数组”。所以，`repeated EmailsEntry` 就意味着**“一个可以装很多张名片的夹子”**。

**所以，`map<string, string> emails` 的真相是 `repeated EmailsEntry emails`。**

- **你的视角**：一个叫 `emails` 的通讯录。
- **Protobuf 的视角**：一个叫 `emails` 的名片夹，里面可以放一堆符合 `EmailsEntry` 模板的名片。

------

### 3. 为什么 Protobuf 要这么做？

你可能会问：为什么不直接发明一个全新的 `map` 类型，非要用旧零件来拼凑呢？

这是个绝妙的设计，主要有两个原因：

1. **重用与简化**：
   Protobuf 的核心优势就是它的序列化和反序列化规则非常高效稳定。通过把 `map` 转换成 `repeated message`，它**完全不需要为 `map` 发明任何新的编码规则**。它只需要按照已有的“列表”和“消息”的规则去处理就行了。这大大降低了 Protobuf 自身的复杂性。
2. **向后兼容性**：
   在 Protobuf 还没有正式支持 `map` 语法之前，程序员们如果想用 map，就必须手动写上面那个 `repeated EmailsEntry` 的结构。现在，官方 `map` 语法在底层被转换成了完全一样的结构。这意味着，用**老方法编码的数据，可以用新语法来解码**，反之亦然。这保证了平滑的过渡和极好的兼容性。

## oneof

### 1. 什么是 `oneof`？（只有一个抽屉的柜子）

想象你有一个 `Notification`（通知）柜子。

```protobuf
message Notification {
  string message = 1; // 柜子上方的公共区域，可以放通用信息

  // oneof 就像柜子中间那个“只能放一样东西”的抽屉
  oneof notification_type {
    string email = 2; // 你可以往里放一封“邮件”
    string sms = 3;   // 或者放一条“短信”
    string push = 4;  // 或者放一个“推送通知”
  }
}
```

- `oneof` 关键字定义了一个**特殊的区域**，就像一个**独占的抽屉**。
- 这个抽屉里可以放 `email`、`sms` 或 `push`，但**永远只能放其中一样**。

------

### 2. “最后放入的会把前面的挤掉” 规则

这是 `oneof` 最核心的行为。

1. **第一步**：你在代码里设置了 `email` 字段。
   - `myNotification.setEmail("user@example.com");`
   - **发生了什么**：你把一封“邮件”放进了抽屉。现在抽屉里是邮件。
2. **第二步**：你紧接着又设置了 `sms` 字段。
   - `myNotification.setSms("+123456789");`
   - **发生了什么**：当你试图把“短信”塞进抽屉时，`oneof` 的规则启动了！它会自动把抽屉里原有的“邮件”**扔掉**，然后把“短信”放进去。

**结论：这个抽屉里永远只有最后被放进去的那样东西。**

------

### 3. 最大的好处：节省空间（序列化）

现在到了关键部分：为什么要用 `oneof`？

当你准备把这个 `Notification` 柜子打包（序列化）通过网络发送出去时：

- 假设抽屉里现在放的是“短信”。
- 打包工人（Protobuf）只会把柜子里的**通用信息 `message`** 和**抽屉里的那条“短信”**打包。
- 对于“邮件”和“推送通知”这两个**空的选项**，打包工人会**完全忽略**它们，就好像它们从来不存在一样。它们不会占用任何二进制空间。

**对比一下，如果你不用 `oneof` 会怎样？**

```protobuf
// 不好的设计
message Notification {
  string message = 1;
  string email = 2; // 可能是空的
  string sms = 3;   // 可能是空的
  string push = 4;  // 可能是空的
}
```

这种设计下，即使 `email` 和 `push` 是空的，它们在协议层面依然是“存在的字段”，可能会占用微小的空间（至少有字段编号的开销）。而 `oneof` 则保证了在任何时候，这三个选项中只有一个会出现在最终的数据流里。

------

### 4. “最后到达的说了算” 规则（反序列化）

文中最后提到一个极端情况：如果收到的数据里，竟然同时包含了 `email` 和 `sms` 两个字段的值，会发生什么？（正常情况下，遵守协议的发送方不会这么做）。

这就像你收到了一个被恶意塞满的抽屉，里面既有邮件又有短信。

**接收方（Protobuf 解码器）的处理方式很简单：**
它会按照数据流的顺序一个一个地解析字段。

1. 它先读到了 `email` 字段，于是把“邮件”放进了抽屉。
2. 紧接着，它又读到了 `sms` 字段。它会严格遵守“最后放入的会挤掉前面的”规则，于是毫不留情地把刚放进去的“邮件”扔掉，换成了“短信”。

**结果：** 即使收到的数据里有多个选项，最终在你的代码对象里生效的，永远是数据流中**最后出现的那一个**。它会“获胜”。

------

### 总结：为什么要用 `oneof`？

1. **强制业务规则**：它在数据结构的层面就保证了“三选一”的逻辑，让你的代码更健壮，不可能出现一个通知既是邮件又是短信的混乱状态。
2. **极致节省空间**：它确保了在任何一次传输中，只有一个选项的数据会被序列化，这对于高性能、高流量的系统至关重要。
3. **代码更清晰**：在接收端，你可以很容易地写一个 `switch` 语句来检查 `notification_type` 到底是哪一种，代码逻辑非常清晰。

## google.protobuf.*

### 1. 什么是 Well-Known Types？（官方标准零件）

想象一下，Protobuf 的基础类型（`int32`, `string` 等）就像是乐高最基础的方块砖。你可以用它们搭建任何东西，但有些场景非常普遍，每次都自己搭很麻烦。

**`google.protobuf.\*`** 就是乐高官方推出的**“特殊零件包”**，里面包含了预先设计好的、解决常见问题的标准组件。你不需要自己从零开始拼，直接拿来用就行。

- `google.protobuf.Timestamp`：这是一个官方设计的**“时间积木”**。
  - **问题**：如果没有它，有人可能会用 `int64` 存秒，有人用 `string` 存 "2023-10-27"，有人用 `int64` 存毫秒。这会造成混乱。
  - **解决方案**：所有人都用这个标准“时间积木”，它内部用秒和纳秒来记录时间，清晰、统一、无歧义。
- `google.protobuf.Duration`：这是一个**“时长积木”**，比如“300秒”。

------

### 2. Wrapper Types 和最关键的问题：“零值” vs “未设置”

这是这段内容最核心、也最难理解的部分。我们用一个非常实际的例子来说明。

**场景**：你在设计一个 API，用户可以更新个人信息。你的 `.proto` 文件里有 `age` 字段。

```protobuf
// 老版本的 proto3 写法
message UpdateUserRequest {
  int32 age = 1;
}
```

**问题来了：**
一个用户发来请求，他的 `age` 字段的值是 `0`。这到底代表两种情况中的哪一种？

1. **情况A**：这个用户是个刚出生的婴儿，他的年龄**确实是 0**。
2. **情况B**：这个用户在提交表单时，**根本没填年龄这一项**，所以系统给了个默认值 `0`。他不希望更新年龄。

在老版本的 `proto3` 中，这两种情况是**无法区分**的！因为只要一个 `int32` 字段没有被显式赋值，它的值在代码里就是 `0`。这就可能导致 bug：用户本来不想改年龄，你却把他的年龄更新成了 0。

#### Wrapper Types 如何解决这个问题？（“把它装进盒子里”）

`google.protobuf.Int32Value` 这类类型被称为**包装器（Wrapper）**。你可以把它想象成一个**透明的小礼品盒**。

现在你把定义改成：

```protobuf
import "google/protobuf/wrappers.proto";

message UpdateUserRequest {
  google.protobuf.Int32Value age = 1; // 把 age 装进了盒子里
}
```

现在再来看那两种情况：

1. **情况A（用户是婴儿，年龄为0）**：
   - 发送方会创建一个 `Int32Value` 的“盒子”，然后在盒子里放一个数字 `0`。
   - 接收方收到了一个**“盒子”**，打开一看，里面是 `0`。现在你明确知道：“哦，用户确实把年龄设置成了0。”
2. **情况B（用户没填年龄）**：
   - 发送方根本**不会创建**这个“盒子”。
   - 接收方**根本收不到**这个 `age` 字段的“盒子”。在 Go 语言里，这个字段就是 `nil`（空指针）。现在你也明确知道了：“哦，用户根本没打算更新年龄。”

**总结：**

- **普通 `int32`**：你只能看到数字 `0`，无法区分来源。
- **包装器 `Int32Value`**：你可以区分“一个装着0的盒子”（值为0）和“根本没有盒子”（未设置/`nil`）。

这就是文中提到的 **Presence Tracking（存在性跟踪）**。

------

### 现代的解决方案：`optional` 关键字

值得一提的是，Protobuf 后来也意识到这个问题很麻烦，于是在较新的语法中，直接引入了 `optional` 关键字来解决同样的问题，而且更简洁。

```protobuf
// 新版本的 proto3 或 Edition 2023 写法
message UpdateUserRequest {
  optional int32 age = 1;
}
```

这个 `optional` 关键字的作用，和使用包装器几乎一模一样，但语法上更干净。它告诉编译器：“这个字段是可选的，我需要知道它到底有没有被设置。”

所以，现在你有了两种方法来解决“零值 vs 未设置”的问题：

1. **老方法**：使用 `google.protobuf.Int32Value` 等包装器。
2. **新方法**：使用 `optional` 关键字。

对于新项目，通常推荐使用 `optional`。但理解包装器的工作原理依然非常重要，因为你会在很多老代码和官方API（如 Google Cloud 的 API）中看到它们的身影。